import { Router, Request, Response } from 'express';
import { authenticate, optionalAuth, AuthRequest } from '../middleware/auth';
import { customDomainsStorage } from '../db/custom-domains-storage';
import { deploymentsStorage } from '../db/deployments-storage';
import { requestDomainSchema } from '@shared/schema';
import dns from 'dns';
import { promisify } from 'util';

const router = Router();

const resolveTxt = promisify(dns.resolveTxt);
const resolveCname = promisify(dns.resolveCname);
const resolve4 = promisify(dns.resolve4);

function isApexDomain(domain: string): boolean {
  const parts = domain.split('.');
  return parts.length === 2 || (parts.length === 3 && parts[0] === 'www');
}

router.post('/', authenticate, async (req: AuthRequest, res: Response) => {
  try {
    const validation = requestDomainSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ 
        error: 'Invalid request',
        details: validation.error.errors 
      });
    }

    const { domain, deploymentSlug } = validation.data;
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const isAvailable = await customDomainsStorage.isDomainAvailable(domain);
    if (!isAvailable) {
      return res.status(409).json({ 
        error: 'Domain already registered',
        message: 'This domain is already connected to another deployment'
      });
    }

    const deployment = await deploymentsStorage.getDeploymentBySlug(deploymentSlug);
    if (!deployment) {
      return res.status(404).json({ 
        error: 'Deployment not found',
        message: 'The deployment slug you provided does not exist'
      });
    }

    // Allow connecting if:
    // 1. User owns the deployment (deployment.userId === userId)
    // 2. Deployment has no owner (deployment.userId === null) - claim it
    if (deployment.userId !== null && deployment.userId !== userId) {
      return res.status(403).json({ 
        error: 'Unauthorized',
        message: 'You can only connect domains to your own deployments'
      });
    }

    // If deployment has no owner, claim it for this user
    if (deployment.userId === null) {
      console.log(`Claiming unowned deployment '${deploymentSlug}' for user ${userId}`);
      await deploymentsStorage.updateDeployment(deployment.id, { userId });
    }

    const customDomain = await customDomainsStorage.createCustomDomain({
      domain,
      deploymentSlug,
      userId,
      isPremium: true
    });

    // Generate the Cloudflare Worker script with the correct Jatevo host URL
    // This must point to the actual Jatevo server, NOT the custom domain
    const jatevoHost = process.env.JATEVO_PUBLIC_URL || process.env.SITE_HOST || 'https://jatevo.ai';
    
    const workerScript = `// Cloudflare Worker for Jatevo Custom Domain
// Domain: ${domain}
// Deployment: ${deploymentSlug}
// Generated by Jatevo Web Builder

const JATEVO_URL = "${jatevoHost}";
const DEPLOYMENT_SLUG = "${deploymentSlug}";

export default {
  async fetch(request) {
    const url = new URL(request.url);
    
    // Proxy all requests to the Jatevo deployment
    const targetUrl = \`\${JATEVO_URL}/sites/\${DEPLOYMENT_SLUG}\${url.pathname}\${url.search}\`;
    
    // Create new request with original headers
    const newRequest = new Request(targetUrl, {
      method: request.method,
      headers: request.headers,
      body: request.body,
      redirect: 'follow'
    });
    
    // Fetch from Jatevo and return response
    const response = await fetch(newRequest);
    
    // Clone response to modify headers if needed
    const newResponse = new Response(response.body, response);
    
    // Add CORS headers for assets
    newResponse.headers.set('Access-Control-Allow-Origin', '*');
    
    return newResponse;
  }
};`;

    // Return Cloudflare Worker setup instructions with the generated script
    res.status(201).json({
      success: true,
      customDomain,
      cloudflareInstructions: {
        message: 'Deploy a Cloudflare Worker to connect your custom domain',
        workerScript,
        jatevoHost,
        deploymentSlug,
        domain,
        steps: [
          'Go to Cloudflare Dashboard → Workers & Pages → Create Worker',
          'Paste the generated worker script and deploy',
          'Go to Worker Settings → Triggers → Add Custom Domain',
          `Enter your domain: ${domain}`,
          'Click "Mark Active" once your Worker is deployed'
        ]
      }
    });
  } catch (error) {
    console.error('Error creating custom domain:', error);
    res.status(500).json({ 
      error: 'Failed to create custom domain',
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

router.get('/', authenticate, async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.id;
    
    if (!userId) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const domains = await customDomainsStorage.getUserCustomDomains(userId);
    
    // Include jatevoHost so frontend can generate correct worker scripts for existing domains
    const jatevoHost = process.env.JATEVO_PUBLIC_URL || process.env.SITE_HOST || 'https://jatevo.ai';
    
    res.json({ 
      domains,
      jatevoHost
    });
  } catch (error) {
    console.error('Error fetching custom domains:', error);
    res.status(500).json({ 
      error: 'Failed to fetch custom domains',
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

router.get('/:id', authenticate, async (req: AuthRequest, res: Response) => {
  try {
    const domainId = parseInt(req.params.id);
    const userId = req.user?.id;

    if (isNaN(domainId)) {
      return res.status(400).json({ error: 'Invalid domain ID' });
    }

    const domain = await customDomainsStorage.getCustomDomainById(domainId);
    
    if (!domain) {
      return res.status(404).json({ error: 'Domain not found' });
    }

    if (domain.userId !== userId) {
      return res.status(403).json({ error: 'Unauthorized' });
    }

    res.json({ domain });
  } catch (error) {
    console.error('Error fetching custom domain:', error);
    res.status(500).json({ 
      error: 'Failed to fetch custom domain',
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

router.post('/:id/verify', authenticate, async (req: AuthRequest, res: Response) => {
  try {
    const domainId = parseInt(req.params.id);
    const userId = req.user?.id;

    if (isNaN(domainId)) {
      return res.status(400).json({ error: 'Invalid domain ID' });
    }

    const domain = await customDomainsStorage.getCustomDomainById(domainId);
    
    if (!domain) {
      return res.status(404).json({ error: 'Domain not found' });
    }

    if (domain.userId !== userId) {
      return res.status(403).json({ error: 'Unauthorized' });
    }

    if (domain.verified) {
      return res.json({ 
        success: true, 
        message: 'Domain is already verified',
        domain 
      });
    }

    let txtVerified = false;
    let routingVerified = false;
    const errors: string[] = [];
    const targetHost = process.env.SITE_HOST || 'sites.jatevo.ai';
    const isApex = isApexDomain(domain.domain);

    try {
      const txtRecords = await resolveTxt(`_jatevo-verify.${domain.domain}`);
      const flatRecords = txtRecords.map(r => r.join(''));
      txtVerified = flatRecords.some(r => r === domain.verificationToken);
      
      if (!txtVerified) {
        errors.push(`TXT record found but value doesn't match. Expected: ${domain.verificationToken}`);
      }
    } catch (dnsError: any) {
      if (dnsError.code === 'ENODATA' || dnsError.code === 'ENOTFOUND') {
        errors.push('TXT record not found. Please add _jatevo-verify TXT record');
      } else {
        errors.push(`TXT lookup failed: ${dnsError.message}`);
      }
    }

    if (isApex) {
      try {
        const domainIPs = await resolve4(domain.domain);
        const targetIPs = await resolve4(targetHost);
        
        routingVerified = domainIPs.some(ip => targetIPs.includes(ip));
        
        if (!routingVerified && domainIPs.length > 0 && targetIPs.length > 0) {
          errors.push(`Domain resolves to ${domainIPs.join(', ')} but ${targetHost} is at ${targetIPs.join(', ')}`);
        }
      } catch (dnsError: any) {
        if (dnsError.code === 'ENODATA' || dnsError.code === 'ENOTFOUND') {
          errors.push(`A record not found. Please add an ALIAS/A record pointing to ${targetHost}`);
        } else {
          errors.push(`A record lookup failed: ${dnsError.message}`);
        }
      }
    } else {
      try {
        const cnameRecords = await resolveCname(domain.domain);
        routingVerified = cnameRecords.some(r => 
          r.toLowerCase() === targetHost.toLowerCase() ||
          r.toLowerCase().endsWith(`.${targetHost.toLowerCase()}`)
        );
        
        if (!routingVerified) {
          errors.push(`CNAME record found but doesn't point to ${targetHost}`);
        }
      } catch (dnsError: any) {
        if (dnsError.code === 'ENODATA' || dnsError.code === 'ENOTFOUND') {
          errors.push(`CNAME record not found. Please point your domain to ${targetHost}`);
        } else {
          errors.push(`CNAME lookup failed: ${dnsError.message}`);
        }
      }
    }

    if (txtVerified && routingVerified) {
      const verifiedDomain = await customDomainsStorage.verifyDomain(domainId);
      
      return res.json({
        success: true,
        verified: true,
        message: 'Domain verified successfully! SSL certificate is being provisioned.',
        domain: verifiedDomain,
        verification: {
          txtVerified: true,
          routingVerified: true
        }
      });
    } else {
      return res.json({
        success: false,
        verified: false,
        message: 'Domain verification incomplete',
        verification: {
          txtVerified,
          routingVerified
        },
        errors,
        instructions: {
          txt: {
            host: '_jatevo-verify',
            value: domain.verificationToken,
            status: txtVerified ? 'verified' : 'pending'
          },
          routing: {
            host: isApex ? '@' : domain.domain,
            type: isApex ? 'ALIAS/A' : 'CNAME',
            value: targetHost,
            status: routingVerified ? 'verified' : 'pending'
          }
        }
      });
    }
  } catch (error) {
    console.error('Error verifying custom domain:', error);
    res.status(500).json({ 
      error: 'Failed to verify custom domain',
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

// Mark domain as active manually (for Cloudflare Workers setup)
router.post('/:id/mark-active', authenticate, async (req: AuthRequest, res: Response) => {
  try {
    const domainId = parseInt(req.params.id);
    const userId = req.user?.id;

    if (isNaN(domainId)) {
      return res.status(400).json({ error: 'Invalid domain ID' });
    }

    const domain = await customDomainsStorage.getCustomDomainById(domainId);
    
    if (!domain) {
      return res.status(404).json({ error: 'Domain not found' });
    }

    if (domain.userId !== userId) {
      return res.status(403).json({ error: 'Unauthorized' });
    }

    if (domain.verified) {
      return res.json({ 
        success: true, 
        message: 'Domain is already active',
        domain 
      });
    }

    // Mark as verified (active) - user confirms they've set up Cloudflare Workers
    const verifiedDomain = await customDomainsStorage.verifyDomain(domainId);
    
    return res.json({
      success: true,
      message: 'Domain marked as active. Make sure your Cloudflare Worker is deployed.',
      domain: verifiedDomain
    });
  } catch (error) {
    console.error('Error marking domain as active:', error);
    res.status(500).json({ 
      error: 'Failed to mark domain as active',
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

router.delete('/:id', authenticate, async (req: AuthRequest, res: Response) => {
  try {
    const domainId = parseInt(req.params.id);
    const userId = req.user?.id;

    if (isNaN(domainId)) {
      return res.status(400).json({ error: 'Invalid domain ID' });
    }

    const domain = await customDomainsStorage.getCustomDomainById(domainId);
    
    if (!domain) {
      return res.status(404).json({ error: 'Domain not found' });
    }

    if (domain.userId !== userId) {
      return res.status(403).json({ error: 'Unauthorized' });
    }

    await customDomainsStorage.deleteCustomDomain(domainId);
    
    res.json({ 
      success: true, 
      message: 'Custom domain removed successfully' 
    });
  } catch (error) {
    console.error('Error deleting custom domain:', error);
    res.status(500).json({ 
      error: 'Failed to delete custom domain',
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

router.get('/check/:domain', async (req: Request, res: Response) => {
  try {
    const domain = req.params.domain.toLowerCase().trim();
    
    if (!domain) {
      return res.status(400).json({ error: 'Domain is required' });
    }

    const isAvailable = await customDomainsStorage.isDomainAvailable(domain);
    
    res.json({ 
      domain,
      available: isAvailable,
      message: isAvailable ? 'Domain is available' : 'Domain is already taken'
    });
  } catch (error) {
    console.error('Error checking domain availability:', error);
    res.status(500).json({ 
      error: 'Failed to check domain availability',
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

router.get('/lookup/:domain', async (req: Request, res: Response) => {
  try {
    const domain = req.params.domain.toLowerCase().trim();
    
    const customDomain = await customDomainsStorage.getCustomDomainByDomain(domain);
    
    if (!customDomain) {
      return res.status(404).json({ 
        error: 'Domain not found',
        message: 'This domain is not registered with Jatevo'
      });
    }

    if (!customDomain.verified) {
      return res.status(400).json({ 
        error: 'Domain not verified',
        message: 'This domain has not been verified yet'
      });
    }

    res.json({
      domain: customDomain.domain,
      deploymentSlug: customDomain.deploymentSlug,
      verified: customDomain.verified,
      sslStatus: customDomain.sslStatus
    });
  } catch (error) {
    console.error('Error looking up domain:', error);
    res.status(500).json({ 
      error: 'Failed to lookup domain',
      details: error instanceof Error ? error.message : String(error)
    });
  }
});

export default router;
